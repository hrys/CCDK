Using the Backend Server
====

Our backend server runs on Linux or OS X, and is a server for multiplayer games.

The backend server has two modes: a real-time mode and a database mode.
Both modes can use run simultaneously in a single process.

The backend server was created using the Virtual Community Engine (VCE). The protocols used by the server are defined in the ssproto.txt file.


## Source Code
The source code for the server is contained in the ```CCDK/backend``` folder.
The ssv and ssbench programs are automatically created when a project is built.

All of the code for the backend server is open source.
Excluding automatically generated boilerplate code, the actual C++ source is small in size. Including comments, the main.cpp and presence.h files come to a total of approximately 2000 lines.

Please feel free to modify the code to add functionality that is not available in the current version of the project, or delete unneeded features when using the server for your own projects.

When using the scaling features of the Shinra System game server, remember that one is not necessarily required to use the backend server that comes with the CCDK.


## Options for Launching ssv

The following will be displayed when running the ssv program with no parameters.

~~~
bash$ ./ssv
Usage:
ssv realtime [OPTIONS]
ssv database [OPTIONS]
ssv realtime database [OPTIONS]
Options:
--dump-sp : dump shared projects with interval
--dump-p : dump projects with interval
--debug-protocol : abort on protocol parser error (for special debug case, dont use in production)
--maxcon=NUMBER : set max number. Absolute max is 200. Requires huge memory if maxcon gets larger.
--emulate-slow-disk=NUMBER : Enable slow disk emulation by milliseconds (sleep after each disk access) 
--channel_max=NUMBER : set max concurrent number of channel members.
--tcp_timeout=SECONDS : set TCP timeout for database and realtime connections
--enable-fsync : Use fsync() when writing a static file (not affect on Redis storage)
--redis-addr HOSTNAME : Address of the redis server.  Default is localhost
~~~

The ssv program requires a minimum of one parameter.
The following is a list of all parameters available for the ssv program.

The ```realtime``` and ```database``` identifiers represent the running mode of the ssv program.
One or both of the run mode identifiers must be specified when running ssv.

~~~
bash$ ./ssv realtime
bash$ ./ssv database
bash$ ./ssv database realtime
bash$ ./ssv database realtime --maxcon=20
bash$ ./ssv database --maxcon=20 --redis-addr 192.168.1.181
bash$ ./ssv database realtime --maxcon=20 --dump-sp --dump-p
bash$ ./ssv database realtime --emulate-slow-disk=5
bash$ ./ssv database realtime --channel_max=300 --redis
bash$ ./ssv realtime --channel_max=300
~~~

The usage of each option flag is specified below.

* ```--dump-sp``` displays and refreshes a list of shared projects at a set interval. This flag is for debugging use.
* ```--dump-p``` displays and refreshes a list of projects hosted by the backend server at a set interval. This is used for debugging.
* ```--debug-protocol``` outputs a detailed log related to the information received by the RPC group of functions. Since the log generated by this option is extremely large, using this option for purposes other than debugging is highly discouraged.
* ```--maxcon=NUMBER``` defines the maximum amount of connections allowed by the server. The maximum number for this option is 200. The reason for this limit has to do with the memory buffer size required for data transmission (VCE already allocates a fixed amount of memory in advance).
* ```--emulate-slow-disk=NUMBER``` this option replicates possible latency of the backend server’s database mode service by emulating standard spinning disk drives like HDDs. This can be used to evaluate how a game will run and what effects using spinning disks will have on the game.
* ```--channel_max=NUMBER``` sets the maximum number of simultaneously active channels on the backend server.
* ```--tcp_timeout=SECONDS``` sets the timeout delay for TCP connections. The default value is 10 seconds.
* ```--enable-fsync``` enables calls to the fsync() function after each write to a static file. This option does not affect operations against Redis services or servers.
* ```--redis-addr HOSTNAME``` sets the IP address or hostname of the Redis server. The default value for this option is ```localhost```.


## Updating the ssproto.txt File

The contents of the ssproto.txt file can be easily changed to allow the addition of new commands on UNIX (Linux, OS X) type environments.

The steps for adding the command below is listed as follows.

1. Edit the ssproto.txt file. For the sake of example we will define ```=c2s foo( int bar )``` which will be a command made from the client to the server.
2. Build the project. By invoking the VCE gen.rb script, files like ssproto_sv.cpp, ssproto_sv.h, ssproto_cli.cpp, ssproto_cli.h will be generated.
3. The compiler will display an error stating that the ssproto_foo_recv() function has not been defined.
4. Define the ssproto_foo_recv() function on the server side.
5. Call the ssproto_foo_send() function on the client side to confirm its functionality.

Future plans for CCDK are in place to make it possible to edit the ssproto.txt file and build projects on Windows environments as well.

For detailed information on the usage of the gen.rb script, please refer to the VCE documentation.


## ssbench

The ssbench program is a stress testing and benchmarking tool for ssv. The program is compiled and created in tandem with ssv when a build is invoked in UNIX environments.

Usage information for ssbench is displayed when the program is called with no command line options.

~~~~
Usage:
ssbench (realtime|database) [--host=IPADDR] [--maxcon=NUMBER] [--channel=NUMBER] [--range=DISTANCE] [--filenum=NUMBER] [--filesize=NUMBER]
~~~~

The ssbench program has real-time and database running modes. However, only one running mode can be specified at a time.

The meaning of each option flag is listed below.

* ```--host=IPADDR``` sets the IP address for the ssv server to stress test. Example: ```--host=192.168.11.10```
* ```--maxcon=NUMBER``` specifies the maximum number of simultaneous connections. The default value is 4. Example:  ```--maxcon=100```
* ```channel=NUMBER``` specifies a channel number to stress test. For example, with the Space Sweeper game, the project ID would be used here to enable the stress testing of an actual game in progress. The default value for this option is 1. Example: ```--channel=38```.
* ```--range=DISTANCE``` changes the distance of the coordinate map used by the nearcast function to determine listening range when used in realtime mode. Details for this option will be highlighted in subsequent text. Example: ```--range=1000```
* ```--filenum=NUMBER``` sets the number of files to be saved when used in database mode. As the file number increases, the frequency of repeated access to a single file decreases and disk usage increases. The default value is 1024. Example: ```--filenum=65536```.
* ```--filesize=NUMBER``` sets the size for a save file when used in database mode. As file size increases disk usage also increases. The default value is 8192. Example: ```--filesize=512```

The following is a list of all options available for use with the ssbench program.

~~~
./ssbench realtime
./ssbench realtime --host=127.0.0.1 --maxcon=50
./ssbench realtime --maxcon=50 --channel=1212 --range=500
./ssbench database
./ssbench database --filenum=10000 --filesize=500
~~~

### Setting the ```--range=DISTANCE``` Command Line Option

The performance of ssv is measured by running ssbench in realtime mode and transmitting a great amount of data to a single channel using the nearcast function. The amount of data is defined as an average of 1500 transmissions to a single socket (a random number of packets from 1 to 100 every sent every 33 milliseconds). As the number of connections increases, the amount of data transmitted increases proportionally.

Note that for this benchmark, all connections will use the join command to connect to the same channel.
This means that if 10 connections have been made to the same channel, when one connection makes a call to the nearcast function, data will be transmitted to the 9 other remaining connections using the nearcast_notify function.
Based on this, we can calculate that the amount of data received by a channel increases exponentially in proportion to the data transmitted by the sender. 
This calculation holds true when using the channelcast function. However, the nearcast function uses data from a coordinate map to determine whether or not to send data. This results in a bandwidth reduction in favor of the using the nearcast function over the channelcast function.

Parameters used with the nearcast function are defined in the ssproto.txt file as follows.

~~~
=c2s 240 nearcast( int x, int y, int range, int type_id, char data[PACKET_SIZE_MAX])
~~~

The parameters ```int x, int y``` represent the coordinates of game events.
The maximum x and y coordinates used by nearcast function can be adjusted by specifying a value for the ```--range``` option. The default value for this option is 0. This dictates that all packets will be generated from the origin coordinates of (0,0) on the game map.
By setting this option to ```--range=1000```, the x and y coordinates will be distributed within a range of 0 to 999 coordinate units.

The value for the range parameter for the nearcast function is set as a constant of 300 coordinate units by ssbench. This means, that game events occurring within a range of 300 coordinate units of a player will have relevant event packets broadcast to all players within that range (transmitted using the update_nearcast_position function at a frequency of 5 random times per second).
This range is referred to as a player’s listening range. The listening range value of 300 coordinate units is Space Sweeper’s standard range.

The final parameter, ```data```, represents information from the game. The ssbench program transmits a predetermined 32-byte binary packet. 32 bytes is the standard packet size for game data transmitted for the Space Sweeper game.

Because the listening range for each player is a range of 300 coordinate units on a map with a size of 2048 coordinate units, the characters of each player are distributed across the map in a similar fashion to the diagram below.

![ssbench sparse](images/ssbench_sparse.png)

This would be the equivalent of specifying ```--range=2048``` as a command line option.
Since, in the diagram, PC1 and PC2 are within each other’s listening range, all data broadcast by PC1 is transmitted to PC2. However, this data is not transmitted to PC3 or PC4. Additionally, since PC3 is not within the listening range of any of the other characters, data broadcast by PC3 will not be transmitted. If no players are within the listening range of each other, there will be no information received on their channel.

Because no information will be sent using the nearcast_notify function when players are more than 300 coordinate units from each other, we can calculate that the amount of information received by the channel will not exceed the amount of data transmitted by the channel squared.

Below is a diagram illustrating distribution on the map if a small value of ```--range=500``` is defined.

![ssbench sparse](images/ssbench_dense.png)

In the diagram above, data broadcast by PC1 is transmitted to PC2 and PC3.
As the range for player distribution decreases, data received by the channelcast function approaches its calculated maximum of the total data transmitted on the channel squared. This is due to the fact that more players are within the listening range of one another.
The default value for the range parameter is a value of 0. This value evenly distributes network traffic in the same fashion as the channelcast function.

The distribution of characters on a map is completely dependent on the settings for a game. Even our Space Sweeper game experiences network traffic biases due to uneven player distribution.



### Maximum disk performance check

You can perform maximum disk performance test with ssbench program.

Setup:

1. Start redis-server 
2. Start ssv with proper --maxcon setting. Ex: ```./ssv database --maxcon=100```
3. Start ssbench with proper --maxcon setting. Ex: ```./ssbench database --maxcon=100```

--maxcon means that you have typical actively playing players' backend load per connection,
it's about 1.2Mbps per connection.

After starting, you will see bandwidth and error count like below:
~~~
stat: send:789802/3106MB/50.3Mbps recv:394901/3085MB/50.0Mbps Error:0
stat: send:791402/3112MB/50.3Mbps recv:395701/3091MB/50.0Mbps Error:0
stat: send:793002/3119MB/50.3Mbps recv:396501/3097MB/50.0Mbps Error:0
stat: send:794602/3125MB/50.3Mbps recv:397301/3103MB/50.0Mbps Error:0
stat: send:796202/3131MB/50.3Mbps recv:398101/3110MB/50.0Mbps Error:0
stat: send:797802/3138MB/50.3Mbps recv:398901/3116MB/50.0Mbps Error:0
stat: send:799402/3144MB/50.3Mbps recv:399701/3122MB/50.0Mbps Error:0
~~~

But if the target backend server is getting slower with disk accesses,
you will have "ping slow" logs like:

~~~
[ping slow dt:689ms id:40][ping slow dt:739ms id:39][ping slow dt:790ms id:38][ping slow dt:841ms id:37][ping slow dt:892ms id:36][ping slow dt:943ms id:35][ping slow dt:401ms id:26][ping slow dt:451ms id:25][ping slow dt:502ms id:24][ping slow dt:553ms id:23][ping slow dt:603ms id:22][ping slow dt:654ms id:21]
~~~

You can stop your load test here, but you can leave it running. Then you probably have connection closed error messsages caused by buffer full.

You can increase maxcon setting step by step, and when you get slow ping,
you can say that it is the maximum disk performance in your environment.
So, if you want to have 100 concurrent players in your system,
you have to confirm ```--maxcon=100``` runs without errors, that requires 120Mbps bandwidth.
(Please note that you probably won't have 100 actively playing players. Many players are just standing or out of projects)

You can also look at "iostat" command during the test to have more information about disk usage.

Here is an example of Linux "iostat" command:

~~~
avg-cpu:  %user   %nice %system %iowait  %steal   %idle
           0.79    0.00    1.85    8.45    0.13   88.77

Device:            tps   Blk_read/s   Blk_wrtn/s   Blk_read   Blk_wrtn
xvda            645.00      1104.00     13456.00       1104      13456
xvdb            155.00       408.00      5888.00        408       5888
~~~

You basically see increasing Blk_read and Blk_wrtn count when --maxcon is increasing.
But at some point this I/O count starts to saturate.
After the point, you won't be able to increase --maxcon.

